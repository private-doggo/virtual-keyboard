"use strict"; var __createBinding = this && this.__createBinding || (Object.create ? function (t, e, i, s) { void 0 === s && (s = i), Object.defineProperty(t, s, { enumerable: !0, get: function () { return e[i] } }) } : function (t, e, i, s) { void 0 === s && (s = i), t[s] = e[i] }), __exportStar = this && this.__exportStar || function (t, e) { for (var i in t) "default" === i || e.hasOwnProperty(i) || __createBinding(e, t, i) }; Object.defineProperty(exports, "__esModule", { value: !0 }), exports.GridStack = void 0; const gridstack_engine_1 = require("./gridstack-engine"), utils_1 = require("./utils"), gridstack_ddi_1 = require("./gridstack-ddi"); __exportStar(require("./types"), exports), __exportStar(require("./utils"), exports), __exportStar(require("./gridstack-engine"), exports), __exportStar(require("./gridstack-ddi"), exports); const GridDefaults = { column: 12, minRow: 0, maxRow: 0, itemClass: "grid-stack-item", placeholderClass: "grid-stack-placeholder", placeholderText: "", handle: ".grid-stack-item-content", handleClass: null, styleInHead: !1, cellHeight: "auto", cellHeightThrottle: 100, margin: 10, auto: !0, minWidth: 768, float: !1, staticGrid: !1, animate: !0, alwaysShowResizeHandle: !1, resizable: { autoHide: !0, handles: "se" }, draggable: { handle: ".grid-stack-item-content", scroll: !1, appendTo: "body" }, disableDrag: !1, disableResize: !1, rtl: "auto", removable: !1, removableOptions: { accept: ".grid-stack-item" }, marginUnit: "px", cellHeightUnit: "px", disableOneColumnMode: !1, oneColumnModeDomSort: !1 }; class GridStack { constructor(t, e = {}) { this._gsEventHandler = {}, this._extraDragRow = 0, this.el = t, (e = e || {}).row && (e.minRow = e.maxRow = e.row, delete e.row); let i = utils_1.Utils.toNumber(t.getAttribute("gs-row")), s = Object.assign(Object.assign({}, GridDefaults), { column: utils_1.Utils.toNumber(t.getAttribute("gs-column")) || 12, minRow: i || (utils_1.Utils.toNumber(t.getAttribute("gs-min-row")) || 0), maxRow: i || (utils_1.Utils.toNumber(t.getAttribute("gs-max-row")) || 0), staticGrid: utils_1.Utils.toBool(t.getAttribute("gs-static")) || !1, _styleSheetClass: "grid-stack-instance-" + (1e4 * Math.random()).toFixed(0), alwaysShowResizeHandle: e.alwaysShowResizeHandle || !1, resizable: { autoHide: !e.alwaysShowResizeHandle, handles: "se" }, draggable: { handle: (e.handleClass ? "." + e.handleClass : e.handle ? e.handle : "") || ".grid-stack-item-content", scroll: !1, appendTo: "body" }, removableOptions: { accept: "." + (e.itemClass || "grid-stack-item") } }); t.getAttribute("gs-animate") && (s.animate = utils_1.Utils.toBool(t.getAttribute("gs-animate"))), this.opts = utils_1.Utils.defaults(e, s), e = null, this.initMargin(), 1 !== this.opts.column && !this.opts.disableOneColumnMode && this._widthOrContainer() <= this.opts.minWidth && (this._prevColumn = this.opts.column, this.opts.column = 1), "auto" === this.opts.rtl && (this.opts.rtl = "rtl" === t.style.direction), this.opts.rtl && this.el.classList.add("grid-stack-rtl"); let r = utils_1.Utils.closestByClass(this.el, GridDefaults.itemClass); if (r && r.gridstackNode && (this.opts._isNested = r.gridstackNode, this.opts._isNested.subGrid = this, this.el.classList.add("grid-stack-nested")), this._isAutoCellHeight = "auto" === this.opts.cellHeight, this._isAutoCellHeight || "initial" === this.opts.cellHeight ? this.cellHeight(void 0, !1) : this.cellHeight(this.opts.cellHeight, !1), this.el.classList.add(this.opts._styleSheetClass), this._setStaticClass(), this.engine = new gridstack_engine_1.GridStackEngine({ column: this.opts.column, float: this.opts.float, maxRow: this.opts.maxRow, onChange: t => { let e = 0; this.engine.nodes.forEach(t => { e = Math.max(e, t.y + t.h) }), t.forEach(t => { let e = t.el; t._removeDOM ? (e && e.remove(), delete t._removeDOM) : this._writePosAttr(e, t) }), this._updateStyles(!1, e) } }), this.opts.auto) { this.batchUpdate(); let t = []; this.getGridItems().forEach(e => { let i = parseInt(e.getAttribute("gs-x")), s = parseInt(e.getAttribute("gs-y")); t.push({ el: e, i: (Number.isNaN(i) ? 1e3 : i) + (Number.isNaN(s) ? 1e3 : s) * this.opts.column }) }), t.sort((t, e) => t.i - e.i).forEach(t => this._prepareElement(t.el)), this.commit() } this.setAnimation(this.opts.animate), this._updateStyles(), 12 != this.opts.column && this.el.classList.add("grid-stack-" + this.opts.column), this.opts.dragIn && GridStack.setupDragIn(this.opts.dragIn, this.opts.dragInOptions), delete this.opts.dragIn, delete this.opts.dragInOptions, this._setupRemoveDrop(), this._setupAcceptWidget(), this._updateWindowResizeEvent() } static init(t = {}, e = ".grid-stack") { let i = GridStack.getGridElement(e); return i ? (i.gridstack || (i.gridstack = new GridStack(i, Object.assign({}, t))), i.gridstack) : ("string" == typeof e ? console.error('GridStack.initAll() no grid was found with selector "' + e + '" - element missing or wrong selector ?\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.') : console.error("GridStack.init() no grid element was passed."), null) } static initAll(t = {}, e = ".grid-stack") { let i = []; return GridStack.getGridElements(e).forEach(e => { e.gridstack || (e.gridstack = new GridStack(e, Object.assign({}, t)), delete t.dragIn, delete t.dragInOptions), i.push(e.gridstack) }), 0 === i.length && console.error('GridStack.initAll() no grid was found with selector "' + e + '" - element missing or wrong selector ?\nNote: ".grid-stack" is required for proper CSS styling and drag/drop, and is the default selector.'), i } static addGrid(t, e = {}) { if (!t) return null; let i = t; if (!t.classList.contains("grid-stack")) { let s = document.implementation.createHTMLDocument(); s.body.innerHTML = `<div class="grid-stack ${e.class || ""}"></div>`, i = s.body.children[0], t.appendChild(i) } let s = GridStack.init(e, i); if (s.opts.children) { let t = s.opts.children; delete s.opts.children, s.load(t) } return s } get placeholder() { if (!this._placeholder) { let t = document.createElement("div"); t.className = "placeholder-content", this.opts.placeholderText && (t.innerHTML = this.opts.placeholderText), this._placeholder = document.createElement("div"), this._placeholder.classList.add(this.opts.placeholderClass, GridDefaults.itemClass, this.opts.itemClass), this.placeholder.appendChild(t) } return this._placeholder } addWidget(t, e) { if (arguments.length > 2) { console.warn("gridstack.ts: `addWidget(el, x, y, width...)` is deprecated. Use `addWidget({x, y, w, content, ...})`. It will be removed soon"); let e = arguments, i = 1, s = { x: e[i++], y: e[i++], w: e[i++], h: e[i++], autoPosition: e[i++], minW: e[i++], maxW: e[i++], minH: e[i++], maxH: e[i++], id: e[i++] }; return this.addWidget(t, s) } let i; if ("string" == typeof t) { let e = document.implementation.createHTMLDocument(); e.body.innerHTML = t, i = e.body.children[0] } else if (0 === arguments.length || 1 === arguments.length && (void 0 !== (s = t).x || void 0 !== s.y || void 0 !== s.w || void 0 !== s.h || void 0 !== s.content)) { let s = t && t.content || ""; e = t; let r = document.implementation.createHTMLDocument(); r.body.innerHTML = `<div class="grid-stack-item ${this.opts.itemClass || ""}"><div class="grid-stack-item-content">${s}</div></div>`, i = r.body.children[0] } else i = t; var s; let r = this._readAttr(i); e = Object.assign({}, e || {}), utils_1.Utils.defaults(e, r); let n = this.engine.prepareNode(e); if (this._writeAttr(i, e), this._insertNotAppend ? this.el.prepend(i) : this.el.appendChild(i), this._prepareElement(i, !0, e), this._updateContainerHeight(), n.subGrid && !n.subGrid.el) { let t = n.el.querySelector(".grid-stack-item-content"); n.subGrid = GridStack.addGrid(t, n.subGrid) } return this._triggerAddEvent(), this._triggerChangeEvent(), i } save(t = !0, e = !1) { let i = this.engine.save(t); if (t && i.forEach(t => { if (t.el && !t.subGrid) { let e = t.el.querySelector(".grid-stack-item-content"); t.content = e ? e.innerHTML : void 0, t.content || delete t.content, delete t.el } }), e) { i.forEach(i => { i.subGrid && (i.subGrid = i.subGrid.save(t, e)) }); let s = Object.assign({}, this.opts); return s.marginBottom === s.marginTop && s.marginRight === s.marginLeft && s.marginTop === s.marginRight && (s.margin = s.marginTop, delete s.marginTop, delete s.marginRight, delete s.marginBottom, delete s.marginLeft), s.rtl === ("rtl" === this.el.style.direction) && (s.rtl = "auto"), this._isAutoCellHeight && (s.cellHeight = "auto"), utils_1.Utils.removeInternalAndSame(s, GridDefaults), s.children = i, s } return i } load(t, e = !0) { let i = GridStack.Utils.sort([...t], -1, this._prevColumn || this.opts.column); this._insertNotAppend = !0, this._prevColumn && this._prevColumn !== this.opts.column && i.some(t => t.x + t.w > this.opts.column) && (this._ignoreLayoutsNodeChange = !0, this.engine.cacheLayout(i, this._prevColumn, !0)); let s = []; if (this.batchUpdate(), e) { [...this.engine.nodes].forEach(t => { i.find(e => t.id === e.id) || ("function" == typeof e ? e(this, t, !1) : (s.push(t), this.removeWidget(t.el, !0, !1))) }) } return i.forEach(t => { let i = t.id || 0 === t.id ? this.engine.nodes.find(e => e.id === t.id) : void 0; if (i) { if (this.update(i.el, t), t.subGrid && t.subGrid.children) { let e = i.el.querySelector(".grid-stack"); e && e.gridstack && (e.gridstack.load(t.subGrid.children), this._insertNotAppend = !0) } } else e && (t = "function" == typeof e ? e(this, t, !0).gridstackNode : this.addWidget(t).gridstackNode) }), this.engine.removedNodes = s, this.commit(), delete this._ignoreLayoutsNodeChange, delete this._insertNotAppend, this } batchUpdate() { return this.engine.batchUpdate(), this } getCellHeight(t = !1) { return !this.opts.cellHeight || "auto" === this.opts.cellHeight || t && this.opts.cellHeightUnit && "px" !== this.opts.cellHeightUnit ? Math.round(this.el.getBoundingClientRect().height) / parseInt(this.el.getAttribute("gs-current-row")) : this.opts.cellHeight } cellHeight(t, e = !0) { if (e && void 0 !== t && this._isAutoCellHeight !== ("auto" === t) && (this._isAutoCellHeight = "auto" === t, this._updateWindowResizeEvent()), "initial" !== t && "auto" !== t || (t = void 0), void 0 === t) { let e = -this.opts.marginRight - this.opts.marginLeft + this.opts.marginTop + this.opts.marginBottom; t = this.cellWidth() + e } let i = utils_1.Utils.parseHeight(t); return this.opts.cellHeightUnit === i.unit && this.opts.cellHeight === i.h ? this : (this.opts.cellHeightUnit = i.unit, this.opts.cellHeight = i.h, e && this._updateStyles(!0, this.getRow()), this) } cellWidth() { return this._widthOrContainer() / this.opts.column } _widthOrContainer() { return this.el.clientWidth || this.el.parentElement.clientWidth || window.innerWidth } commit() { return this.engine.commit(), this._triggerRemoveEvent(), this._triggerAddEvent(), this._triggerChangeEvent(), this } compact() { return this.engine.compact(), this._triggerChangeEvent(), this } column(t, e = "moveScale") { if (this.opts.column === t) return this; let i, s = this.opts.column; return 1 === t ? this._prevColumn = s : delete this._prevColumn, this.el.classList.remove("grid-stack-" + s), this.el.classList.add("grid-stack-" + t), this.opts.column = this.engine.column = t, 1 === t && this.opts.oneColumnModeDomSort && (i = [], this.getGridItems().forEach(t => { t.gridstackNode && i.push(t.gridstackNode) }), i.length || (i = void 0)), this.engine.updateNodeWidths(s, t, i, e), this._isAutoCellHeight && this.cellHeight(), this._ignoreLayoutsNodeChange = !0, this._triggerChangeEvent(), delete this._ignoreLayoutsNodeChange, this } getColumn() { return this.opts.column } getGridItems() { return Array.from(this.el.children).filter(t => t.matches("." + this.opts.itemClass) && !t.matches("." + this.opts.placeholderClass)) } destroy(t = !0) { if (this.el) return this._updateWindowResizeEvent(!0), this.setStatic(!0, !1), this.setAnimation(!1), t ? this.el.parentNode.removeChild(this.el) : (this.removeAll(t), this.el.classList.remove(this.opts._styleSheetClass)), this._removeStylesheet(), this.el.removeAttribute("gs-current-row"), delete this.opts._isNested, delete this.opts, delete this._placeholder, delete this.engine, delete this.el.gridstack, delete this.el, this } float(t) { return this.engine.float = t, this._triggerChangeEvent(), this } getFloat() { return this.engine.float } getCellFromPixel(t, e = !1) { let i, s = this.el.getBoundingClientRect(); i = e ? { top: s.top + document.documentElement.scrollTop, left: s.left } : { top: this.el.offsetTop, left: this.el.offsetLeft }; let r = t.left - i.left, n = t.top - i.top, o = s.width / this.opts.column, l = s.height / parseInt(this.el.getAttribute("gs-current-row")); return { x: Math.floor(r / o), y: Math.floor(n / l) } } getRow() { return Math.max(this.engine.getRow(), this.opts.minRow) } isAreaEmpty(t, e, i, s) { return this.engine.isAreaEmpty(t, e, i, s) } makeWidget(t) { let e = GridStack.getElement(t); return this._prepareElement(e, !0), this._updateContainerHeight(), this._triggerAddEvent(), this._triggerChangeEvent(), e } on(t, e) { if (-1 !== t.indexOf(" ")) { return t.split(" ").forEach(t => this.on(t, e)), this } if ("change" === t || "added" === t || "removed" === t || "enable" === t || "disable" === t) { let i = "enable" === t || "disable" === t; this._gsEventHandler[t] = i ? t => e(t) : t => e(t, t.detail), this.el.addEventListener(t, this._gsEventHandler[t]) } else "drag" === t || "dragstart" === t || "dragstop" === t || "resizestart" === t || "resize" === t || "resizestop" === t || "dropped" === t ? this._gsEventHandler[t] = e : console.log("GridStack.on(" + t + ') event not supported, but you can still use $(".grid-stack").on(...) while jquery-ui is still used internally.'); return this } off(t) { if (-1 !== t.indexOf(" ")) { return t.split(" ").forEach(t => this.off(t)), this } return "change" !== t && "added" !== t && "removed" !== t && "enable" !== t && "disable" !== t || this._gsEventHandler[t] && this.el.removeEventListener(t, this._gsEventHandler[t]), delete this._gsEventHandler[t], this } removeWidget(t, e = !0, i = !0) { return GridStack.getElements(t).forEach(t => { if (t.parentElement !== this.el) return; let s = t.gridstackNode; s || (s = this.engine.nodes.find(e => t === e.el)), s && (delete t.gridstackNode, gridstack_ddi_1.GridStackDDI.get().remove(t), this.engine.removeNode(s, e, i), e && t.parentElement && t.remove()) }), i && (this._triggerRemoveEvent(), this._triggerChangeEvent()), this } removeAll(t = !0) { return this.engine.nodes.forEach(t => { delete t.el.gridstackNode, gridstack_ddi_1.GridStackDDI.get().remove(t.el) }), this.engine.removeAll(t), this._triggerRemoveEvent(), this } setAnimation(t) { return t ? this.el.classList.add("grid-stack-animate") : this.el.classList.remove("grid-stack-animate"), this } setStatic(t, e = !0) { return this.opts.staticGrid === t ? this : (this.opts.staticGrid = t, this._setupRemoveDrop(), this._setupAcceptWidget(), this.engine.nodes.forEach(t => this._prepareDragDropByNode(t)), e && this._setStaticClass(), this) } update(t, e) { if (arguments.length > 2) { console.warn("gridstack.ts: `update(el, x, y, w, h)` is deprecated. Use `update({x, w, content, ...})`. It will be removed soon"); let i = arguments, s = 1; return e = { x: i[s++], y: i[s++], w: i[s++], h: i[s++] }, this.update(t, e) } return GridStack.getElements(t).forEach(t => { if (!t || !t.gridstackNode) return; let i = t.gridstackNode, s = Object.assign({}, e); delete s.autoPosition; let r, n = ["x", "y", "w", "h"]; if (n.some(t => void 0 !== s[t] && s[t] !== i[t]) && (r = {}, n.forEach(t => { r[t] = void 0 !== s[t] ? s[t] : i[t], delete s[t] })), !r && (s.minW || s.minH || s.maxW || s.maxH) && (r = {}), s.content) { let e = t.querySelector(".grid-stack-item-content"); e && e.innerHTML !== s.content && (e.innerHTML = s.content), delete s.content } let o = !1, l = !1; for (const t in s) "_" !== t[0] && i[t] !== s[t] && (i[t] = s[t], o = !0, l = l || !this.opts.staticGrid && ("noResize" === t || "noMove" === t || "locked" === t)); r && (this.engine.cleanNodes().beginUpdate(i).moveNode(i, r), this._updateContainerHeight(), this._triggerChangeEvent(), this.engine.endUpdate()), o && this._writeAttr(t, i), l && this._prepareDragDropByNode(i) }), this } margin(t) { if (!("string" == typeof t && t.split(" ").length > 1)) { let e = utils_1.Utils.parseHeight(t); if (this.opts.marginUnit === e.unit && this.opts.margin === e.h) return } return this.opts.margin = t, this.opts.marginTop = this.opts.marginBottom = this.opts.marginLeft = this.opts.marginRight = void 0, this.initMargin(), this._updateStyles(!0), this } getMargin() { return this.opts.margin } willItFit(t) { if (arguments.length > 1) { console.warn("gridstack.ts: `willItFit(x,y,w,h,autoPosition)` is deprecated. Use `willItFit({x, y,...})`. It will be removed soon"); let t = arguments, e = 0, i = { x: t[e++], y: t[e++], w: t[e++], h: t[e++], autoPosition: t[e++] }; return this.willItFit(i) } return this.engine.willItFit(t) } _triggerChangeEvent() { if (this.engine.batchMode) return this; let t = this.engine.getDirtyNodes(!0); return t && t.length && (this._ignoreLayoutsNodeChange || this.engine.layoutsNodesChange(t), this._triggerEvent("change", t)), this.engine.saveInitial(), this } _triggerAddEvent() { return this.engine.batchMode ? this : (this.engine.addedNodes && this.engine.addedNodes.length > 0 && (this._ignoreLayoutsNodeChange || this.engine.layoutsNodesChange(this.engine.addedNodes), this.engine.addedNodes.forEach(t => { delete t._dirty }), this._triggerEvent("added", this.engine.addedNodes), this.engine.addedNodes = []), this) } _triggerRemoveEvent() { return this.engine.batchMode ? this : (this.engine.removedNodes && this.engine.removedNodes.length > 0 && (this._triggerEvent("removed", this.engine.removedNodes), this.engine.removedNodes = []), this) } _triggerEvent(t, e) { let i = e ? new CustomEvent(t, { bubbles: !1, detail: e }) : new Event(t); return this.el.dispatchEvent(i), this } _removeStylesheet() { return this._styles && (utils_1.Utils.removeStylesheet(this._styles._id), delete this._styles), this } _updateStyles(t = !1, e) { if (t && this._removeStylesheet(), this._updateContainerHeight(), 0 === this.opts.cellHeight) return this; let i = this.opts.cellHeight, s = this.opts.cellHeightUnit, r = `.${this.opts._styleSheetClass} > .${this.opts.itemClass}`; if (!this._styles) { let t = "gridstack-style-" + (1e5 * Math.random()).toFixed(), e = this.opts.styleInHead ? void 0 : this.el.parentNode; if (this._styles = utils_1.Utils.createStylesheet(t, e), !this._styles) return this; this._styles._id = t, this._styles._max = 0, utils_1.Utils.addCSSRule(this._styles, r, `min-height: ${i}${s}`); let n = this.opts.marginTop + this.opts.marginUnit, o = this.opts.marginBottom + this.opts.marginUnit, l = this.opts.marginRight + this.opts.marginUnit, h = this.opts.marginLeft + this.opts.marginUnit, a = `${r} > .grid-stack-item-content`, d = `.${this.opts._styleSheetClass} > .grid-stack-placeholder > .placeholder-content`; utils_1.Utils.addCSSRule(this._styles, a, `top: ${n}; right: ${l}; bottom: ${o}; left: ${h};`), utils_1.Utils.addCSSRule(this._styles, d, `top: ${n}; right: ${l}; bottom: ${o}; left: ${h};`), utils_1.Utils.addCSSRule(this._styles, `${r} > .ui-resizable-ne`, `right: ${l}`), utils_1.Utils.addCSSRule(this._styles, `${r} > .ui-resizable-e`, `right: ${l}`), utils_1.Utils.addCSSRule(this._styles, `${r} > .ui-resizable-se`, `right: ${l}; bottom: ${o}`), utils_1.Utils.addCSSRule(this._styles, `${r} > .ui-resizable-nw`, `left: ${h}`), utils_1.Utils.addCSSRule(this._styles, `${r} > .ui-resizable-w`, `left: ${h}`), utils_1.Utils.addCSSRule(this._styles, `${r} > .ui-resizable-sw`, `left: ${h}; bottom: ${o}`) } if ((e = e || this._styles._max) > this._styles._max) { let t = t => i * t + s; for (let i = this._styles._max + 1; i <= e; i++) { let e = t(i); utils_1.Utils.addCSSRule(this._styles, `${r}[gs-y="${i - 1}"]`, `top: ${t(i - 1)}`), utils_1.Utils.addCSSRule(this._styles, `${r}[gs-h="${i}"]`, `height: ${e}`), utils_1.Utils.addCSSRule(this._styles, `${r}[gs-min-h="${i}"]`, `min-height: ${e}`), utils_1.Utils.addCSSRule(this._styles, `${r}[gs-max-h="${i}"]`, `max-height: ${e}`) } this._styles._max = e } return this } _updateContainerHeight() { if (!this.engine || this.engine.batchMode) return this; let t = this.getRow() + this._extraDragRow, e = parseInt(getComputedStyle(this.el)["min-height"]); if (e > 0) { let i = Math.round(e / this.getCellHeight(!0)); t < i && (t = i) } if (this.el.setAttribute("gs-current-row", String(t)), 0 === t) return this.el.style.removeProperty("height"), this; let i = this.opts.cellHeight, s = this.opts.cellHeightUnit; return i ? (this.el.style.height = t * i + s, this) : this } _prepareElement(t, e = !1, i) { i || (t.classList.add(this.opts.itemClass), i = this._readAttr(t)), t.gridstackNode = i, i.el = t, i.grid = this; let s = Object.assign({}, i); return i = this.engine.addNode(i, e), utils_1.Utils.same(i, s) || this._writeAttr(t, i), this._prepareDragDropByNode(i), this } _writePosAttr(t, e) { return void 0 !== e.x && null !== e.x && t.setAttribute("gs-x", String(e.x)), void 0 !== e.y && null !== e.y && t.setAttribute("gs-y", String(e.y)), e.w && t.setAttribute("gs-w", String(e.w)), e.h && t.setAttribute("gs-h", String(e.h)), this } _writeAttr(t, e) { if (!e) return this; this._writePosAttr(t, e); let i = { autoPosition: "gs-auto-position", minW: "gs-min-w", minH: "gs-min-h", maxW: "gs-max-w", maxH: "gs-max-h", noResize: "gs-no-resize", noMove: "gs-no-move", locked: "gs-locked", id: "gs-id", resizeHandles: "gs-resize-handles" }; for (const s in i) e[s] ? t.setAttribute(i[s], String(e[s])) : t.removeAttribute(i[s]); return this } _readAttr(t) { let e = {}; e.x = utils_1.Utils.toNumber(t.getAttribute("gs-x")), e.y = utils_1.Utils.toNumber(t.getAttribute("gs-y")), e.w = utils_1.Utils.toNumber(t.getAttribute("gs-w")), e.h = utils_1.Utils.toNumber(t.getAttribute("gs-h")), e.maxW = utils_1.Utils.toNumber(t.getAttribute("gs-max-w")), e.minW = utils_1.Utils.toNumber(t.getAttribute("gs-min-w")), e.maxH = utils_1.Utils.toNumber(t.getAttribute("gs-max-h")), e.minH = utils_1.Utils.toNumber(t.getAttribute("gs-min-h")), e.autoPosition = utils_1.Utils.toBool(t.getAttribute("gs-auto-position")), e.noResize = utils_1.Utils.toBool(t.getAttribute("gs-no-resize")), e.noMove = utils_1.Utils.toBool(t.getAttribute("gs-no-move")), e.locked = utils_1.Utils.toBool(t.getAttribute("gs-locked")), e.resizeHandles = t.getAttribute("gs-resize-handles"), e.id = t.getAttribute("gs-id"); for (const t in e) { if (!e.hasOwnProperty(t)) return; e[t] || 0 === e[t] || delete e[t] } return e } _setStaticClass() { let t = ["grid-stack-static"]; return this.opts.staticGrid ? (this.el.classList.add(...t), this.el.setAttribute("gs-static", "true")) : (this.el.classList.remove(...t), this.el.removeAttribute("gs-static")), this } onParentResize() { if (!this.el || !this.el.clientWidth) return; let t = !this.opts.disableOneColumnMode && this.el.clientWidth <= this.opts.minWidth, e = !1; return 1 === this.opts.column !== t && (e = !0, this.opts.animate && this.setAnimation(!1), this.column(t ? 1 : this._prevColumn), this.opts.animate && this.setAnimation(!0)), this._isAutoCellHeight && (!e && this.opts.cellHeightThrottle ? (this._cellHeightThrottle || (this._cellHeightThrottle = utils_1.Utils.throttle(() => this.cellHeight(), this.opts.cellHeightThrottle)), this._cellHeightThrottle()) : this.cellHeight()), this.engine.nodes.forEach(t => { t.subGrid && t.subGrid.onParentResize() }), this } _updateWindowResizeEvent(t = !1) { const e = (this._isAutoCellHeight || !this.opts.disableOneColumnMode) && !this.opts._isNested; return t || !e || this._windowResizeBind ? !t && e || !this._windowResizeBind || (window.removeEventListener("resize", this._windowResizeBind), delete this._windowResizeBind) : (this._windowResizeBind = this.onParentResize.bind(this), window.addEventListener("resize", this._windowResizeBind)), this } static getElement(t = ".grid-stack-item") { return utils_1.Utils.getElement(t) } static getElements(t = ".grid-stack-item") { return utils_1.Utils.getElements(t) } static getGridElement(t) { return GridStack.getElement(t) } static getGridElements(t) { return utils_1.Utils.getElements(t) } initMargin() { let t, e = 0, i = []; return "string" == typeof this.opts.margin && (i = this.opts.margin.split(" ")), 2 === i.length ? (this.opts.marginTop = this.opts.marginBottom = i[0], this.opts.marginLeft = this.opts.marginRight = i[1]) : 4 === i.length ? (this.opts.marginTop = i[0], this.opts.marginRight = i[1], this.opts.marginBottom = i[2], this.opts.marginLeft = i[3]) : (t = utils_1.Utils.parseHeight(this.opts.margin), this.opts.marginUnit = t.unit, e = this.opts.margin = t.h), void 0 === this.opts.marginTop ? this.opts.marginTop = e : (t = utils_1.Utils.parseHeight(this.opts.marginTop), this.opts.marginTop = t.h, delete this.opts.margin), void 0 === this.opts.marginBottom ? this.opts.marginBottom = e : (t = utils_1.Utils.parseHeight(this.opts.marginBottom), this.opts.marginBottom = t.h, delete this.opts.margin), void 0 === this.opts.marginRight ? this.opts.marginRight = e : (t = utils_1.Utils.parseHeight(this.opts.marginRight), this.opts.marginRight = t.h, delete this.opts.margin), void 0 === this.opts.marginLeft ? this.opts.marginLeft = e : (t = utils_1.Utils.parseHeight(this.opts.marginLeft), this.opts.marginLeft = t.h, delete this.opts.margin), this.opts.marginUnit = t.unit, this.opts.marginTop === this.opts.marginBottom && this.opts.marginLeft === this.opts.marginRight && this.opts.marginTop === this.opts.marginRight && (this.opts.margin = this.opts.marginTop), this } static setupDragIn(t, e) { } movable(t, e) { return this } resizable(t, e) { return this } disable() { return this } enable() { return this } enableMove(t) { return this } enableResize(t) { return this } _setupAcceptWidget() { return this } _setupRemoveDrop() { return this } _prepareDragDropByNode(t) { return this } _onStartMoving(t, e, i, s, r, n) { } _dragOrResize(t, e, i, s, r, n) { } _leave(t, e) { } } exports.GridStack = GridStack, GridStack.Utils = utils_1.Utils, GridStack.Engine = gridstack_engine_1.GridStackEngine;